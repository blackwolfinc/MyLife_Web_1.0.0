{
  "_args": [
    [
      {
        "raw": "web-vitals@^0.2.4",
        "scope": null,
        "escapedName": "web-vitals",
        "name": "web-vitals",
        "rawSpec": "^0.2.4",
        "spec": ">=0.2.4 <0.3.0",
        "type": "range"
      },
      "/home/bagas/Documents/2.February/MyLife_Web_1.0.0"
    ]
  ],
  "_from": "web-vitals@^0.2.4",
  "_hasShrinkwrap": false,
  "_id": "web-vitals@0.2.4",
  "_location": "/web-vitals",
  "_nodeVersion": "10.17.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/web-vitals_0.2.4_1595555194565_0.13297130873702856"
  },
  "_npmUser": {
    "name": "philipwalton",
    "email": "philip@philipwalton.com"
  },
  "_npmVersion": "6.14.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "web-vitals@^0.2.4",
    "scope": null,
    "escapedName": "web-vitals",
    "name": "web-vitals",
    "rawSpec": "^0.2.4",
    "spec": ">=0.2.4 <0.3.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/web-vitals/-/web-vitals-0.2.4.tgz",
  "_shasum": "ec3df43c834a207fd7cdefd732b2987896e08511",
  "_shrinkwrap": null,
  "_spec": "web-vitals@^0.2.4",
  "_where": "/home/bagas/Documents/2.February/MyLife_Web_1.0.0",
  "author": {
    "name": "Philip Walton",
    "email": "philip@philipwalton.com",
    "url": "http://philipwalton.com"
  },
  "bugs": {
    "url": "https://github.com/GoogleChrome/web-vitals/issues"
  },
  "dependencies": {},
  "description": "Easily measure performance metrics in JavaScript",
  "devDependencies": {
    "@babel/core": "^7.10.5",
    "@babel/preset-env": "^7.10.4",
    "@typescript-eslint/eslint-plugin": "^3.7.0",
    "@typescript-eslint/parser": "^3.7.0",
    "@wdio/cli": "^6.3.4",
    "@wdio/local-runner": "^6.3.4",
    "@wdio/mocha-framework": "^6.3.0",
    "@wdio/selenium-standalone-service": "^6.1.14",
    "@wdio/spec-reporter": "^6.3.0",
    "babel-eslint": "^10.1.0",
    "body-parser": "^1.19.0",
    "chromedriver": "^84.0.1",
    "eslint": "^7.5.0",
    "eslint-config-google": "^0.14.0",
    "express": "^4.17.1",
    "fs-extra": "^9.0.1",
    "husky": "^4.2.5",
    "npm-run-all": "^4.1.5",
    "nunjucks": "^3.2.2",
    "rollup": "^2.23.0",
    "rollup-plugin-babel": "^4.4.0",
    "rollup-plugin-terser": "^6.1.0",
    "typescript": "^3.9.7",
    "wdio-chromedriver-service": "^6.0.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-6BjspCO9VriYy12z356nL6JBS0GYeEcA457YyRzD+dD6XYCQ75NKhcOHUMHentOE7OcVCIXXDvOm0jKFfQG2Gg==",
    "shasum": "ec3df43c834a207fd7cdefd732b2987896e08511",
    "tarball": "https://registry.npmjs.org/web-vitals/-/web-vitals-0.2.4.tgz",
    "fileCount": 48,
    "unpackedSize": 85500,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfGj17CRA9TVsSAnZWagAAyyEQAIvVituI08IIpbzJ9Rcv\n9p/XF2aubTQPUNbRpLvN6lB95ed+yqXPAGVmGGncfuxQmDHNvH5v0CaO1p+g\nQzYvA7kkr8z6vYo35E3mDvqYW6Dm/9RuxH6+3yt0V37PbNoFp6CVkJjQRsvE\nhYSY6TrdZn/DYSXBFog9X5P/LPkj5AmB/37OJbHzCrYi7wI6jqW5TbPzQ5Pi\nPBorp/oCMEGIwhfwE/A1RiO57Xi97/b0w61A8/d2QEFwewnCGwkq/fRE8uqT\nhiM6TJA6fQoucb+OFTs+8PN0v2+7/tKbqNEx9sG1IZwJCDMvqctls3oHVJ+R\n1jhcE9alzyBfDFuDqzRe2v+JnYEPqUUCyHQathfr/FWGIaYlqHiuQ8qPPGaS\nkbIGimGFtP34etsjdJ0TiIEzWFmVndKkLooj8Rah5s4Tdi7jLk+jayuEIfg0\ntaXXx74/nwOh6FHhjXsCDsVibgci7LYqEs1I1wHTa+xXMD52MUWEnFlhVhzf\nSgzYxlD3pqw3zXL0Kx1Uo/scDT0kYHAAPUzcw2ybLZbgO+/XlnccNErMCdS1\n3XqzVpyhisjnEXmRibN9bjolnnX6FnDcW5aE4vdRc+f5B1Vppmd9ew6qQ+VN\njTzO9xkohEm+/jG5rUN07i9zeGRmyjY3xIc5566yQ60HrybZCoyoc//psbw9\nuFZX\r\n=Mqi0\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "dist",
    "src"
  ],
  "gitHead": "ab52d6706c3104058e39a7ace2a09f70997ca1f0",
  "homepage": "https://github.com/GoogleChrome/web-vitals#readme",
  "husky": {
    "hooks": {
      "pre-commit": "npm run lint"
    }
  },
  "keywords": [
    "crux",
    "performance",
    "metrics",
    "CLS",
    "FCP",
    "FID",
    "LCP",
    "TTFB"
  ],
  "license": "Apache-2.0",
  "main": "dist/web-vitals.es5.umd.min.js",
  "maintainers": [
    {
      "name": "philipwalton",
      "email": "philip@philipwalton.com"
    }
  ],
  "module": "dist/web-vitals.es5.min.js",
  "name": "web-vitals",
  "optionalDependencies": {},
  "readme": "# `web-vitals`\n\n- [Overview](#overview)\n- [Installation](#installation)\n- [Usage](#usage)\n  - [Log the results to the console](#log-the-results-to-the-console)\n  - [Report the value on every change](#report-the-value-on-every-change)\n  - [Report only the delta of changes](#report-only-the-delta-of-changes)\n  - [Send the results to an analytics endpoint](#send-the-results-to-an-analytics-endpoint)\n  - [Send the results to Google Analytics](#send-the-results-to-google-analytics)\n  - [Send the results to Google Tag Manager](#send-the-results-to-google-tag-manager)\n  - [Load `web-vitals` from a CDN](#load-web-vitals-from-a-cdn)\n- [API](#api)\n  - [Types](#types)\n  - [Functions](#functions)\n- [Development](#development)\n- [Browser Support](#browser-support)\n\n## Overview\n\nThe `web-vitals` library is a tiny (~1K), modular library for measuring all the [Web Vitals](https://web.dev/vitals/) metrics on real users, in a way that accurately matches how they're measured by Chrome and reported to other Google tools (e.g. [Chrome User Experience Report](https://developers.google.com/web/tools/chrome-user-experience-report), [Page Speed Insights](https://developers.google.com/speed/pagespeed/insights/), [Search Console's Speed Report](https://webmasters.googleblog.com/2019/11/search-console-speed-report.html)).\n\nThe library supports all of the [Core Web Vitals](https://web.dev/vitals/#core-web-vitals) as well as all of the [other Web Vitals](https://web.dev/vitals/#other-web-vitals) that can be measured [in the field](https://web.dev/user-centric-performance-metrics/#how-metrics-are-measured):\n\n### Core Web Vitals\n\n- [Cumulative Layout Shift (CLS)](https://web.dev/cls/)\n- [First Input Delay (FID)](https://web.dev/fid/)\n- [Largest Contentful Paint (LCP)](https://web.dev/lcp/)\n\n### Other Web Vitals\n\n- [First Contentful Paint (FCP)](https://web.dev/fcp/)\n- [Time to First Byte (TTFB)](https://web.dev/time-to-first-byte/)\n\n## Installation\n\nYou can install this library from npm by running:\n\n```sh\nnpm install web-vitals\n```\n\n_**Note:** If you're not using npm, you can still load `web-vitals` via `<script>` tags from a CDN like [unpkg.com](https://unpkg.com). See the [load `web-vitals` from a CDN](#load-web-vitals-from-a-cdn) usage example below for details._\n\n## Usage\n\nEach of the Web Vitals metrics are exposed as a single function that takes an `onReport` callback. This callback will fire any time either:\n\n- The final value of the metric has been determined.\n- The current metric value needs to be [reported right away](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#advice-hidden) (due to the page being unloaded or backgrounded).\n\n### Log the results to the console\n\nThe following example logs the result of each metric to the console once its value is ready to report.\n\n```js\nimport {getCLS, getFID, getLCP} from 'web-vitals';\n\ngetCLS(console.log);\ngetFID(console.log);\ngetLCP(console.log);\n```\n\n_**Note:** some of these metrics will not report until the user has interacted with the page, switched tabs, or the page starts to unload. If you don't see the values logged to the console immediately, try switching tabs and then switching back._\n\n### Report the value on every change\n\nIn most cases, you only want to call `onReport` when the metric is ready. However, for metrics like LCP and CLS (where the value may change over time) you can pass an optional, second argument (`reportAllChanges`). If `true` then `onReport` will be called any time the value of the metric changes, or once the final value has been determined.\n\nThis could be useful if, for example, you want to report the current LCP candidate as the page is loading, or you want to report layout shifts (and the current CLS value) as users are interacting with the page. In general, though, using `reportAllChanges` is not needed (or recommended).\n\n```js\nimport {getCLS, getFID, getLCP} from 'web-vitals';\n\ngetCLS(console.log, true);\ngetFID(console.log); // Does not take a `reportAllChanges` param.\ngetLCP(console.log, true);\n```\n\n_**Note:** when using the `reportAllChanges` option, pay attention to the `isFinal` property of the reported metric, which will indicate whether or not the value might change in the future. See the [API](#api) reference below for more details._\n\n### Report only the delta of changes\n\nSome analytics providers allow you to update the value of a metric, even after you've already sent it to their servers (overwriting the previously-sent value with the same `id`).\n\nOther analytics providers, however, do not allow this, so instead of reporting the new value, you need to report only the delta (the difference between the current value and the last-reported value). You can then compute the total value by summing all metric deltas sent with the same ID.\n\nThe following example shows how to use the `id` and `delta` properties:\n\n```js\nimport {getCLS, getFID, getLCP} from 'web-vitals';\n\nfunction logDelta({name, id, delta}) {\n  console.log(`${name} matching ID ${id} changed by ${delta}`);\n}\n\ngetCLS(logDelta);\ngetFID(logDelta);\ngetLCP(logDelta);\n```\n\n_**Note:** the first time the `onReport` function is called, its `value` and `delta` properties will be the same._\n\n### Send the results to an analytics endpoint\n\nThe following example measures each of the Core Web Vitals metrics and reports them to a hypothetical `/analytics` endpoint, as soon as each is ready to be sent.\n\nThe `sendToAnalytics()` function uses the [`navigator.sendBeacon()`](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon) method (if available), but falls back to the [`fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) API when not.\n\n```js\nimport {getCLS, getFID, getLCP} from 'web-vitals';\n\nfunction sendToAnalytics(metric) {\n  const body = JSON.stringify(metric);\n  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.\n  (navigator.sendBeacon && navigator.sendBeacon('/analytics', body)) ||\n      fetch('/analytics', {body, method: 'POST', keepalive: true});\n}\n\ngetCLS(sendToAnalytics);\ngetFID(sendToAnalytics);\ngetLCP(sendToAnalytics);\n```\n\n### Send the results to Google Analytics\n\nGoogle Analytics does not support reporting metric distributions in any of its built-in reports; however, if you set a unique dimension value (in this case, the metric `id`) on every metric instance that you send to Google Analytics, including that dimension in a custom report will allow you to construct a distribution manually.\n\nUsing the [Google Analytics Reporting API](https://developers.google.com/analytics/devguides/reporting) and a tool like [Data Studio](https://datastudio.google.com/) (or your own visualization library), you can create dashboards with histograms reporting quantile data (the 75th percentile is recommended) for all of the Web Vitals metrics.\n\nThe following code examples show how to send your metrics to Google Analytics in order to enable reporting quantile data:\n\n#### Using `analytics.js`\n\n```js\nimport {getCLS, getFID, getLCP} from 'web-vitals';\n\nfunction sendToGoogleAnalytics({name, delta, id}) {\n  // Assumes the global `ga()` function exists, see:\n  // https://developers.google.com/analytics/devguides/collection/analyticsjs\n  ga('send', 'event', {\n    eventCategory: 'Web Vitals',\n    eventAction: name,\n    // Google Analytics metrics must be integers, so the value is rounded.\n    // For CLS the value is first multiplied by 1000 for greater precision\n    // (note: increase the multiplier for greater precision if needed).\n    eventValue: Math.round(name === 'CLS' ? delta * 1000 : delta),\n    // The `id` value will be unique to the current page load. When sending\n    // multiple values from the same page (e.g. for CLS), Google Analytics can\n    // compute a total by grouping on this ID (note: requires `eventLabel` to\n    // be a dimension in your report).\n    eventLabel: id,\n    // Use a non-interaction event to avoid affecting bounce rate.\n    nonInteraction: true,\n  });\n}\n\ngetCLS(sendToGoogleAnalytics);\ngetFID(sendToGoogleAnalytics);\ngetLCP(sendToGoogleAnalytics);\n```\n\n#### Using `gtag.js`\n\n```js\nimport {getCLS, getFID, getLCP} from 'web-vitals';\n\nfunction sendToGoogleAnalytics({name, delta, id}) {\n  // Assumes the global `gtag()` function exists, see:\n  // https://developers.google.com/analytics/devguides/collection/gtagjs\n  gtag('event', name, {\n    event_category: 'Web Vitals',\n    // Google Analytics metrics must be integers, so the value is rounded.\n    // For CLS the value is first multiplied by 1000 for greater precision\n    // (note: increase the multiplier for greater precision if needed).\n    value: Math.round(name === 'CLS' ? delta * 1000 : delta),\n    // The `id` value will be unique to the current page load. When sending\n    // multiple values from the same page (e.g. for CLS), Google Analytics can\n    // compute a total by grouping on this ID (note: requires `eventLabel` to\n    // be a dimension in your report).\n    event_label: id,\n    // Use a non-interaction event to avoid affecting bounce rate.\n    non_interaction: true,\n  });\n}\n\ngetCLS(sendToGoogleAnalytics);\ngetFID(sendToGoogleAnalytics);\ngetLCP(sendToGoogleAnalytics);\n```\n\n### Send the results to Google Tag Manager\n\nThe following example measures each of the Core Web Vitals metrics and sends them as separate `dataLayer-events` to be used by Google Tag Manager. With the `web-vitals` trigger you send the metrics to any tag inside your account (see [this comment](https://github.com/GoogleChrome/web-vitals/pull/28#discussion_r422701126) for implementation details).\n\n```js\nimport {getCLS, getFID, getLCP} from 'web-vitals';\n\nfunction sendToGTM({name, delta, id}) {\n  // Assumes the global `dataLayer` array exists, see:\n  // https://developers.google.com/tag-manager/devguide\n  dataLayer.push({\n    event: 'web-vitals',\n    event_category: 'Web Vitals',\n    event_action: name,\n    // Google Analytics metrics must be integers, so the value is rounded.\n    // For CLS the value is first multiplied by 1000 for greater precision\n    // (note: increase the multiplier for greater precision if needed).\n    event_value: Math.round(name === 'CLS' ? delta * 1000 : delta),\n    // The `id` value will be unique to the current page load. When sending\n    // multiple values from the same page (e.g. for CLS), Google Analytics can\n    // compute a total by grouping on this ID (note: requires `eventLabel` to\n    // be a dimension in your report).\n    event_label: id,\n  });\n}\n\ngetCLS(sendToGTM);\ngetFID(sendToGTM);\ngetLCP(sendToGTM);\n```\n\n### Load `web-vitals` from a CDN\n\nThe recommended way to use the `web-vitals` package is to install it from npm and integrate it into your build process. However, if you're not using npm, it's still possible to use `web-vitals` by requesting it from a CDN that serves npm package files.\n\nThe following examples show how to load `web-vitals` from [unpkg.com](https://unpkg.com) using either classic or module scripts:\n\n```html\n<!-- Load `web-vitals` using a classic script that sets the global `webVitals` object. -->\n<script defer src=\"https://unpkg.com/web-vitals@0.2.4/dist/web-vitals.es5.umd.min.js\"></script>\n<script>\naddEventListener('DOMContentLoaded', function() {\n  webVitals.getCLS(console.log);\n  webVitals.getFID(console.log);\n  webVitals.getLCP(console.log);\n});\n</script>\n```\n\n```html\n<!-- Load `web-vitals` using a module script. -->\n<script type=\"module\">\n  import {getCLS, getFID, getLCP} from 'https://unpkg.com/web-vitals@0.2.4/dist/web-vitals.es5.min.js?module';\n\n  getCLS(console.log);\n  getFID(console.log);\n  getLCP(console.log);\n</script>\n```\n\n_**Note:** it's safe to use module scripts in legacy browsers because unknown script types are ignored._\n\n## API\n\n### Types:\n\n#### `Metric`\n\n```ts\ninterface Metric {\n  // The name of the metric (in acronym form).\n  name: 'CLS' | 'FCP' | 'FID' | 'LCP' | 'TTFB';\n\n  // The current value of the metric.\n  value: number;\n\n  // The delta between the current value and the last-reported value.\n  // On the first report, `delta` and `value` will always be the same.\n  delta: number;\n\n  // A unique ID representing this particular metric that's specific to the\n  // current page. This ID can be used by an analytics tool to dedupe\n  // multiple values sent for the same metric, or to group multiple deltas\n  // together and calculate a total.\n  id: string;\n\n  // `false` if the value of the metric may change in the future,\n  // for the current page.\n  isFinal: boolean;\n\n  // Any performance entries used in the metric value calculation.\n  // Note, entries will be added to the array as the value changes.\n  entries: PerformanceEntry[];\n}\n```\n\n#### `ReportHandler`\n\n```ts\ninterface ReportHandler {\n  (metric: Metric): void;\n}\n```\n\n### Functions:\n\n#### `getCLS()`\n\n```ts\ntype getCLS = (onReport: ReportHandler, reportAllChanges?: boolean) => void\n```\n\nCalculates the [CLS](https://web.dev/cls/) value for the current page and calls the `onReport` function once the value is ready to be reported, along with all `layout-shift` performance entries that were used in the metric value calculation. The reported value is a [double](https://heycam.github.io/webidl/#idl-double) (corresponding to a [layout shift value](https://wicg.github.io/layout-instability/#layout-shift-value)).\n\nIf the `reportAllChanges` param is `true`, the `onReport` function will be called any time a new `layout-shift` performance entry is dispatched, or once the final value of the metric has been determined.\n\n_**Important:** unlike other metrics, CLS continues to monitor changes for the entire lifespan of the page&mdash;including if the user returns to the page after it's been hidden/backgrounded. However, since browsers often [will not fire additional callbacks once the user has backgrounded a page](https://developers.google.com/web/updates/2018/07/page-lifecycle-api#advice-hidden), `onReport` is always called when the page's visibility state changes to hidden. As a result, the `onReport` function might be called multiple times during the same page load (see [Reporting only the delta of changes](#report-only-the-delta-of-changes) for how to manage this)._\n\n#### `getFCP()`\n\n```ts\ntype getFCP = (onReport: ReportHandler) => void\n```\n\nCalculates the [FCP](https://web.dev/fcp/) value for the current page and calls the `onReport` function once the value is ready, along with the relevant `paint` performance entry used to determine the value. The reported value is a `DOMHighResTimeStamp`.\n\n#### `getFID()`\n\n```ts\ntype getFID = (onReport: ReportHandler) => void\n```\n\nCalculates the [FID](https://web.dev/fid/) value for the current page and calls the `onReport` function once the value is ready, along with the relevant `first-input` performance entry used to determine the value (and optionally the input event if using the [FID polyfill](#fid-polyfill)). The reported value is a `DOMHighResTimeStamp`.\n\n_**Important:** since FID is only reported after the user interacts with the page, it's possible that it will not be reported for some page loads._\n\n#### `getLCP()`\n\n```ts\ntype getLCP = (onReport: ReportHandler, reportAllChanges?: boolean) => void\n```\n\nCalculates the [LCP](https://web.dev/lcp/) value for the current page and calls the `onReport` function once the value is ready (along with the relevant `largest-contentful-paint` performance entries used to determine the value). The reported value is a `DOMHighResTimeStamp`.\n\nIf the `reportAllChanges` param is `true`, the `onReport` function will be called any time a new `largest-contentful-paint` performance entry is dispatched, or once the final value of the metric has been determined.\n\n#### `getTTFB()`\n\n```ts\ntype getTTFB = (onReport: ReportHandler) => void\n```\n\nCalculates the [TTFB](https://web.dev/time-to-first-byte/) value for the current page and calls the `onReport` function once the page has loaded, along with the relevant `navigation` performance entry used to determine the value. The reported value is a `DOMHighResTimeStamp`.\n\nNote, this function waits until after the page is loaded to call `onReport` in order to ensure all properties of the `navigation` entry are populated. This is useful if you want to report on other metrics exposed by the [Navigation Timing API](https://w3c.github.io/navigation-timing/).\n\nFor example, the TTFB metric starts from the page's [time origin](https://www.w3.org/TR/hr-time-2/#sec-time-origin), which means it [includes](https://developers.google.com/web/fundamentals/performance/navigation-and-resource-timing#the_life_and_timings_of_a_network_request) time spent on DNS lookup, connection negotiation, network latency, and unloading the previous document. If, in addition to TTFB, you want a metric that excludes these timings and _just_ captures the time spent making the request and receiving the first byte of the response, you could compute that from data found on the performance entry:\n\n```js\nimport {getTTFB} from 'web-vitals';\n\ngetTTFB((metric) => {\n  // Calculate the request time by subtracting from TTFB\n  // everything that happened prior to the request starting.\n  const requestTime = metric.value - metric.entries[0].requestStart;\n  console.log('Request time:', requestTime);\n});\n```\n\n_**Note:** browsers that do not support `navigation` entries will fall back to\nusing `performance.timing` (with the timestamps converted from epoch time to `DOMHighResTimeStamp`). This ensures code referencing these values (like in the example above) will work the same in all browsers._\n\n## Browser Support\n\nThis code has been tested and will run without error in all major browsers as well as Internet Explorer back to version 9 (when transpiled to ES5). However, some of the APIs required to capture these metrics are only available in Chromium-based browsers (e.g. Chrome, Edge, Opera, Samsung Internet).\n\nBrowser support for each function is as follows:\n\n- `getCLS()`: Chromium\n- `getFCP()`: Chromium\n- `getFID()`: Chromium, Firefox, Safari, Internet Explorer (with polyfill, [see below](#fid-polyfill))\n- `getLCP()`: Chromium\n- `getTTFB()`: Chromium, Firefox, Safari, Internet Explorer\n\n### FID Polyfill\n\nThe `getFID()` function will work in all browsers if the page has included the [FID polyfill](https://github.com/GoogleChromeLabs/first-input-delay).\n\nBrowsers that support the native [Event Timing API](https://wicg.github.io/event-timing/) will use that and report the metric value from the `first-input` performance entry.\n\nBrowsers that **do not** support the native Event Timing API will use the value reported by the polyfill, and the `entries` array will contain a plain-object version of the native [`PerformanceEventTiming`](https://wicg.github.io/event-timing/#sec-performance-event-timing) object.\n\n_**Note:** the `duration` and `processingEnd` properties of the `PerformanceEventTiming` will not be present, as they're not exposed by the polyfill._\n\n## Development\n\n### Building the code\n\nThe `web-vitals` source code is written in TypeScript. To transpile the code and build the production bundles, run the following command.\n\n```sh\nnpm run build\n```\n\nTo build the code and watch for changes, run:\n\n```sh\nnpm run watch\n```\n\n### Running the tests\n\nThe `web-vitals` code is tested in real browsers using [webdriver.io](https://webdriver.io/). Use the following command to run the tests:\n\n```sh\nnpm test\n```\n\nTo test any of the APIs manually, you can start the test server\n\n```sh\nnpm run test:server\n```\n\nThen navigate to `http://localhost:9090/test/<view>`, where `<view>` is the basename of one the templates under [/test/views/](/test/views/).\n\nYou'll likely want to combine this with `npm run watch` to ensure any changes you make are transpiled and rebuilt.\n\n## License\n\n[Apache 2.0](/LICENSE)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/GoogleChrome/web-vitals.git"
  },
  "scripts": {
    "build": "run-s clean build:ts build:js",
    "build:js": "rollup -c",
    "build:ts": "tsc -b",
    "clean": "rm -rf dist tsconfig.tsbuildinfo",
    "dev": "run-p watch serve",
    "lint": "eslint \"*.js\" \"src/**/*.ts\" \"test/**/*.js\"",
    "lint:fix": "eslint --fix \"*.js\" \"src/**/*.ts\" \"test/**/*.js\"",
    "postversion": "git push --follow-tags",
    "release:major": "npm version major -m 'Release v%s' && npm publish",
    "release:minor": "npm version minor -m 'Release v%s' && npm publish",
    "release:patch": "npm version patch -m 'Release v%s' && npm publish",
    "test": "npm-run-all build -p -r test:*",
    "test:e2e": "wdio wdio.conf.js",
    "test:server": "node test/server.js",
    "version": "run-s build",
    "watch": "run-p watch:*",
    "watch:js": "rollup -c -w",
    "watch:ts": "tsc -b -w"
  },
  "typings": "dist/index.d.ts",
  "version": "0.2.4"
}
