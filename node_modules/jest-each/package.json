{
  "_args": [
    [
      {
        "raw": "jest-each@^26.6.2",
        "scope": null,
        "escapedName": "jest-each",
        "name": "jest-each",
        "rawSpec": "^26.6.2",
        "spec": ">=26.6.2 <27.0.0",
        "type": "range"
      },
      "/home/bagas/Documents/2.February/MyLife_Web_1.0.0/node_modules/jest-jasmine2"
    ]
  ],
  "_from": "jest-each@^26.6.2",
  "_hasShrinkwrap": false,
  "_id": "jest-each@26.6.2",
  "_location": "/jest-each",
  "_nodeVersion": "14.15.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/jest-each_26.6.2_1604321497192_0.6768150455076427"
  },
  "_npmUser": {
    "name": "simenb",
    "email": "sbekkhus91@gmail.com"
  },
  "_npmVersion": "lerna/3.22.1/node@v14.15.0+x64 (darwin)",
  "_phantomChildren": {
    "ansi-styles": "4.3.0",
    "supports-color": "7.2.0"
  },
  "_requested": {
    "raw": "jest-each@^26.6.2",
    "scope": null,
    "escapedName": "jest-each",
    "name": "jest-each",
    "rawSpec": "^26.6.2",
    "spec": ">=26.6.2 <27.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/jest-circus",
    "/jest-jasmine2"
  ],
  "_resolved": "https://registry.npmjs.org/jest-each/-/jest-each-26.6.2.tgz",
  "_shasum": "02526438a77a67401c8a6382dfe5999952c167cb",
  "_shrinkwrap": null,
  "_spec": "jest-each@^26.6.2",
  "_where": "/home/bagas/Documents/2.February/MyLife_Web_1.0.0/node_modules/jest-jasmine2",
  "author": {
    "name": "Matt Phillips",
    "url": "mattphillips"
  },
  "bugs": {
    "url": "https://github.com/facebook/jest/issues"
  },
  "dependencies": {
    "@jest/types": "^26.6.2",
    "chalk": "^4.0.0",
    "jest-get-type": "^26.3.0",
    "jest-util": "^26.6.2",
    "pretty-format": "^26.6.2"
  },
  "description": "Parameterised tests for Jest",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "integrity": "sha512-Mer/f0KaATbjl8MCJ+0GEpNdqmnVmDYqCTJYTvoo7rqmRiDllmp2AYN+06F93nXcY3ur9ShIjS+CO/uD+BbH4A==",
    "shasum": "02526438a77a67401c8a6382dfe5999952c167cb",
    "tarball": "https://registry.npmjs.org/jest-each/-/jest-each-26.6.2.tgz",
    "fileCount": 13,
    "unpackedSize": 35756,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfoADZCRA9TVsSAnZWagAArZsP/j1jxDNqxb0CCFhUWbPH\nr85/k/3zaG/J+uo5ckB0pSIWOubGekK10zANNqFE6ag1j7WWi24BDutfELzH\nIbXvGZQc/0DHlfpYsE0pkR4myHTk6RpmwXzX5ZFSxeMsZJUZLj/gXun/AAQk\nyb26bc0QVtbrTytjdaceG4bwYCtyDonyd9bEqZ9g5XXGwbiRD9lItwFYdOdK\nlMCY9wab4fLDK/sa/oAD7nb+WJNwdbJsS6JtRrIUJnad0ppyFAS+bB2XWZ9x\nghr4lO265Yh7E6GaR/plt0kAVkGhxfFdFeMzHkIBeSCuxBJrOhzKo8SVStDc\nJHMXOlcE0HOe4oJ7gracmHTpWPP0/xnAaNy13X2/pfZIgP3sT8Hhnd/HgFvq\nUrE9H4HNSoZ0fnXsxcF59X0Ol2wYnGZVkOzt1jn9wz24MfFeHFQd4/9ugiRQ\n7Imf+sM9vB0C+Ackmk1DoEaLCrqSOLvWcUgUEZTSwrta4g6T5PFQPMz32dog\nBweaL1ThhOKR73hZTc81bvIDsByQomkQkIcw+yQ4S6HbyzlQdiGWuU9Y6sZD\ny5t5lvRSO3MWSvAGg5kciM2BOEY2ZgZPZQHbOIyrtMOKXg9RNZD5KitfTTA7\nuj/+x5hSR5WokdMjdEWkgQ86IBjNgHoZJH/Tr1NlUKAo/DsVuvABHWb3vFju\njHdy\r\n=ewvG\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "engines": {
    "node": ">= 10.14.2"
  },
  "gitHead": "4c46930615602cbf983fb7e8e82884c282a624d5",
  "homepage": "https://github.com/facebook/jest#readme",
  "keywords": [
    "jest",
    "parameterised",
    "test",
    "each"
  ],
  "license": "MIT",
  "main": "build/index.js",
  "maintainers": [
    {
      "name": "scotthovestadt",
      "email": "scott.hovestadt@gmail.com"
    },
    {
      "name": "rubennorte",
      "email": "rubennorte@gmail.com"
    },
    {
      "name": "simenb",
      "email": "sbekkhus91@gmail.com"
    },
    {
      "name": "fb",
      "email": "opensource+npm@fb.com"
    },
    {
      "name": "mattphillips",
      "email": "matt@mattphillips.io"
    },
    {
      "name": "davidzilburg",
      "email": "davidzilburg@gmail.com"
    }
  ],
  "name": "jest-each",
  "optionalDependencies": {},
  "publishConfig": {
    "access": "public"
  },
  "readme": "<div align=\"center\">\n  <h1>jest-each</h1>\n  Jest Parameterised Testing\n</div>\n\n<hr />\n\n[![version](https://img.shields.io/npm/v/jest-each.svg?style=flat-square)](https://www.npmjs.com/package/jest-each) [![downloads](https://img.shields.io/npm/dm/jest-each.svg?style=flat-square)](http://npm-stat.com/charts.html?package=jest-each&from=2017-03-21) [![MIT License](https://img.shields.io/npm/l/jest-each.svg?style=flat-square)](https://github.com/facebook/jest/blob/master/LICENSE)\n\nA parameterised testing library for [Jest](https://jestjs.io/) inspired by [mocha-each](https://github.com/ryym/mocha-each).\n\njest-each allows you to provide multiple arguments to your `test`/`describe` which results in the test/suite being run once per row of parameters.\n\n## Features\n\n- `.test` to runs multiple tests with parameterised data\n  - Also under the alias: `.it`\n- `.test.only` to only run the parameterised tests\n  - Also under the aliases: `.it.only` or `.fit`\n- `.test.skip` to skip the parameterised tests\n  - Also under the aliases: `.it.skip` or `.xit` or `.xtest`\n- `.test.concurrent`\n  - Also under the alias: `.it.concurrent`\n- `.test.concurrent.only`\n  - Also under the alias: `.it.concurrent.only`\n- `.test.concurrent.skip`\n  - Also under the alias: `.it.concurrent.skip`\n- `.describe` to runs test suites with parameterised data\n- `.describe.only` to only run the parameterised suite of tests\n  - Also under the aliases: `.fdescribe`\n- `.describe.skip` to skip the parameterised suite of tests\n  - Also under the aliases: `.xdescribe`\n- Asynchronous tests with `done`\n- Unique test titles with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n  - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n  - `%s`- String.\n  - `%d`- Number.\n  - `%i` - Integer.\n  - `%f` - Floating point value.\n  - `%j` - JSON.\n  - `%o` - Object.\n  - `%#` - Index of the test case.\n  - `%%` - single percent sign ('%'). This does not consume an argument.\n- ðŸ–– Spock like data tables with [Tagged Template Literals](#tagged-template-literal-of-rows)\n\n---\n\n- [Demo](#demo)\n- [Installation](#installation)\n- [Importing](#importing)\n- APIs\n  - [Array of Rows](#array-of-rows)\n    - [Usage](#usage)\n  - [Tagged Template Literal of rows](#tagged-template-literal-of-rows)\n    - [Usage](#usage-1)\n\n## Demo\n\n#### Tests without jest-each\n\n![Current jest tests](assets/default-demo.gif)\n\n#### Tests can be re-written with jest-each to:\n\n**`.test`**\n\n![Current jest tests](assets/test-demo.gif)\n\n**`.test` with Tagged Template Literals**\n\n![Current jest tests](assets/tagged-template-literal.gif)\n\n**`.describe`**\n\n![Current jest tests](assets/describe-demo.gif)\n\n## Installation\n\n`npm i --save-dev jest-each`\n\n`yarn add -D jest-each`\n\n## Importing\n\njest-each is a default export so it can be imported with whatever name you like.\n\n```js\n// es6\nimport each from 'jest-each';\n```\n\n```js\n// es5\nconst each = require('jest-each').default;\n```\n\n## Array of rows\n\n### API\n\n#### `each([parameters]).test(name, testFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `testFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.test`:\n\n- name: `String` the title of the `test`.\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each([parameters]).describe(name, suiteFn)`\n\n##### `each`:\n\n- parameters: `Array` of Arrays with the arguments that are passed into the `suiteFn` for each row\n  - _Note_ If you pass in a 1D array of primitives, internally it will be mapped to a table i.e. `[1, 2, 3] -> [[1], [2], [3]]`\n\n##### `.describe`:\n\n- name: `String` the title of the `describe`\n  - Generate unique test titles by positionally injecting parameters with [`printf` formatting](https://nodejs.org/api/util.html#util_util_format_format_args):\n    - `%p` - [pretty-format](https://www.npmjs.com/package/pretty-format).\n    - `%s`- String.\n    - `%d`- Number.\n    - `%i` - Integer.\n    - `%f` - Floating point value.\n    - `%j` - JSON.\n    - `%o` - Object.\n    - `%#` - Index of the test case.\n    - `%%` - single percent sign ('%'). This does not consume an argument.\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test('returns the result of adding %d to %d', (a, b, expected) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.only('returns the result of adding %d to %d', (a, b, expected) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.skip('returns the result of adding %d to %d', (a, b, expected) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.concurrent(name, fn)`\n\nAliases: `.it.concurrent(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.concurrent(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.concurrent.only(name, fn)`\n\nAliases: `.it.concurrent.only(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.concurrent.only(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### `.test.concurrent.skip(name, fn)`\n\nAliases: `.it.concurrent.skip(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).test.concurrent.skip(\n  'returns the result of adding %d to %d',\n  (a, b, expected) => {\n    expect(a + b).toBe(expected);\n  },\n);\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach([['hello'], ['mr'], ['spy']]).test(\n  'gives 007 secret message: %s',\n  (str, done) => {\n    const asynchronousSpy = message => {\n      expect(message).toBe(str);\n      done();\n    };\n    callSomeAsynchronousFunction(asynchronousSpy)(str);\n  },\n);\n```\n\n#### `.describe(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).describe('.add(%d, %d)', (a, b, expected) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).describe.only('.add(%d, %d)', (a, b, expected) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n]).describe.skip('.add(%d, %d)', (a, b, expected) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n---\n\n## Tagged Template Literal of rows\n\n### API\n\n#### `each[tagged template].test(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings separated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.test`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n- testFn: `Function` the test logic, this is the function that will receive the parameters of each row as function arguments\n\n#### `each[tagged template].describe(name, suiteFn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n##### `each` takes a tagged template string with:\n\n- First row of variable name column headings separated with `|`\n- One or more subsequent rows of data supplied as template literal expressions using `${value}` syntax.\n\n##### `.describe`:\n\n- name: `String` the title of the `test`, use `$variable` in the name string to inject test values into the test title from the tagged template expressions\n  - To inject nested object values use you can supply a keyPath i.e. `$variable.path.to.value`\n- suiteFn: `Function` the suite of `test`/`it`s to be ran, this is the function that will receive the parameters in each row as function arguments\n\n### Usage\n\n#### `.test(name, fn)`\n\nAlias: `.it(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.only(name, fn)`\n\nAliases: `.it.only(name, fn)` or `.fit(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.only('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### `.test.skip(name, fn)`\n\nAliases: `.it.skip(name, fn)` or `.xit(name, fn)` or `.xtest(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.test.skip('returns $expected when adding $a to $b', ({a, b, expected}) => {\n  expect(a + b).toBe(expected);\n});\n```\n\n#### Asynchronous `.test(name, fn(done))`\n\nAlias: `.it(name, fn(done))`\n\n```js\neach`\n  str\n  ${'hello'}\n  ${'mr'}\n  ${'spy'}\n`.test('gives 007 secret message: $str', ({str}, done) => {\n  const asynchronousSpy = message => {\n    expect(message).toBe(str);\n    done();\n  };\n  callSomeAsynchronousFunction(asynchronousSpy)(str);\n});\n```\n\n#### `.describe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n\n  test('does not mutate first arg', () => {\n    a + b;\n    expect(a).toBe(a);\n  });\n\n  test('does not mutate second arg', () => {\n    a + b;\n    expect(b).toBe(b);\n  });\n});\n```\n\n#### `.describe.only(name, fn)`\n\nAliases: `.fdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.only('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n#### `.describe.skip(name, fn)`\n\nAliases: `.xdescribe(name, fn)`\n\n```js\neach`\n  a    | b    | expected\n  ${1} | ${1} | ${2}\n  ${1} | ${2} | ${3}\n  ${2} | ${1} | ${3}\n`.describe.skip('$a + $b', ({a, b, expected}) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected);\n  });\n});\n```\n\n## License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/jest.git",
    "directory": "packages/jest-each"
  },
  "types": "build/index.d.ts",
  "version": "26.6.2"
}
